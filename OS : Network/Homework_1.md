1. **프로세스 구조에 대해 가능한 상세하게 설명해주세요.**
   - text(= CODE): 0과 1로 이뤄진 코드
   - DATA: 코드에 필요한 전역 변수 / 초기화 된 데이터
   - STACK: 임시 데이터 (함수호출, 로컬 변수 등), 코드에서 변수에 할당 된 값
   - HEAP: 코드에서 동적으로 만들어지는 데이터 
     - 동적 메모리를 위한 공간 
     - 코드를 실행하면서 추가적으로 동적 할당이 필요한 공간은 실행을 해보기 전까지 알 수 없기 때문에 미리 이런 공간을 만들고 동적으로 메모리가 필요한 공간이 있으면 여기에다 넣음 
2. **컨텍스트 스위칭에 대해 가능한 상세하게 설명해주세요.**
   - Context Switching, 문맥 교환
   - CPU에 실행할 프로세스를 교체하는 기술
   - PC, SP만 바꿔주면 프로세스 저장상태를 기반으로 실행 가능 
   - CPU가 프로세스를 실행하고 있는데 인터럽트로 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존 실행되고 있는 프로세스 정보를 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업 
   - 프로세스가 서로 대기 <-> 실행을 번갈아가면서 하는 것 
3. **프로세스간에는 어떤 기술을 사용해서 통신하는지, 왜 해당 기술을 사용해서 통신해야하는지를 쓰레드와 비교해서 설명해주세요.**
  - 프로세스는 독립된 실행객체라서 다른 프로세스의 특정 주소를 지칭할 방법이 없어 직접 커뮤니케이션이 불가능 -> 커널영역에서 IPC(InterProcess Communication) 기술을 사용하며 통신
  - 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행하는데 각 프로세스의 상태를 확인하고 데이터 송수신이 필요하기 때문에 IPC 필요 
  - IPC의 대표적인 기법으로는 `Message Queue`, `Sharea Memory`, `Pipe` 등이 있다. (= 모두 커널 공간을 사용)
  - 스레드는 Code, Data, Data 영역을 공유하기 때문에 별도의 통신 기술이 필요하지 않음
4. **프로세스와 쓰레드의 차이점에 대해 설명해주세요.**
   - 프로세스는 메모리에 load되어 실행되고 있는 프로그램. (실행 중인 프로그램) 한 프로그램에서 실행되는 여러 프로세스가 동시에 존재 가능
   - 스레드는 최소의 프로세스 동작 단위. 프로세스 내에서 실행되는 각각의 일. 하나의 프로세스 생성 -> 하나의 스레드가 같이 생성 됨. 1프로세스 1스레드 (여기서 여러개의 스레드를 가질 수 있다? = 멀티 스레드)
5. **언제 멀티 프로세스를 사용하고, 언제 멀티 쓰레드를 써야하는지 가능한 구체적으로 설명해주세요.**
   - 멀티 프로세스는 여러 개의 프로세스가 필요한 경우(하나의 프로세스가 root 역할 해야할 때) 사용
   - 멀티 스레드는 프로그램이 여러 개의 독립적인 일을 해야 하는 경우
   - 계산기나 메모장 같은 서로 완전히 별개의 프로그램은 독립적인 프로세스, 서로 관련된 기능들은 멀티 스레드로 구현 
6. **쓰레드 동기화란 무엇이며 왜 사용해야하는지 예를 들어 설명해주세요.**
   - 작업들 사이의 수행 시간(시기)를 맞추는 것 (= 동시에 일어나거나, 일정한 간격을 두거나, 공유 자원에 대해 단 하나의 스레드만 접근이 가능하게 끔하여 수행 간격을 조정)
   - 멀티 스레드를 사용하는 프로그램에서 두 개 이상의 스레드가 공유 데이터에 접근하는 경우에 사용 
     - 공유 변수에 두 개 이상의 스레드가 접근하여 연산을 하는 등 
7. **뮤텍스와 세마포어의 차이점에 대해 간략히 설명해주세요.**
   - 세마포어: 임계 구역에 들어갈 스레드의 개수를 설정 (= 하나 이상)
   - 뮤텍스: 임계 구역에 들어갈 스레드를 하나로 제한하는 것 
8. **가상 메모리와 페이징 시스템에 대해 구체적으로 설명해주세요.**
   - 가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술. 어떤 프로세스를 실행할 때 프로세스 전체가 메모리에 적재되지 않고도 실행이 가능 하도록 하는 것 
   - 페이징 시스템은 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 지정하고 검색하는 메모리 관리 기법 
     - 크기가 동일한 페이지(page)로 가상 주소 공간과 이에 매칭하는 물리 주소 공간 관리 
     - 페이지(page) 번호를 기반으로 가상 주소와 물리 주소 매핑 정보를 기록하고 사용 
9. **요구 페이징과 페이지 폴트에 대해 구체적으로 설명해주세요.**
   - 요구 페이징(Demand Paging)은 프로세스는 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함 (= 더 이상 필요하지 않은 페이지 프레임은 다시 저장 매체에 저장)
   - 페이지 폴트(page fault)는 인터럽트(Interrupt)
     - 필요할 때 메모리를 올리는 기술이 필요한데 그것이 페이지 폴트(= 어떤 페이지가 실제 메모리에 없을 때 일어나는 인터럽트 )
     - CPU가 요청한 가상주소 Page Table에 해당 내용이 invalid 되어 있으면 page fault 인터럽트 발생 -> 페이지를 찾아서 update
     - OS에서는 페이지 폴트가 인터럽트이기 때문에 커널모드로 변경 후 IDT(Interrupt Descriptor Table)에서 커널함수를 호출하여 실행
     - 페이지폴트가 자주 일어나게 되면 실행속도가 느려진다 
10. **MMU와 TLB에 대해 구체적으로 설명해주세요.**
    - TLB (Translation Lookaside Buffer) : 페이지 정보 캐쉬
    - MMU (Memory Management Unit) : CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치 
    - MMU가 물리 주소를 확인하기 위해서는 메모리를 갔다와야 하는데 한번 처리할 때마다 400 cycles가 걸림 -> CPU에서 다른 시도 -> TLB. TLB의 역할은 캐시로 MMU가 메모리에 갔다올 때마다 물리주소를 TLB에 저장해둠 
    - TLB는 CPU 내에 적재되어 있고, cycles을 아끼게 됨 (= 거의 200 cycles)

