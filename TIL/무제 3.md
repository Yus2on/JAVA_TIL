12/07

스프링부트프로젝트 생성했을때 

1. 프로젝트에 필요한 라이브러리를 패키지 단위로 관리 가능 
2. 



pom.xml 에서

spring-boot-starter-web과 spring-boot-starter-test 는 각각의 jar 파일 형태 -> 얘네[만 디펜던시로 추가해도 관련된 라이브러리가 같이 다운됨 

test jar파일 하나만 다운받아도 걔가 다운되는 순간 테스트에 필요한 모든 라이브러리가 같이 다운됨 

web.jar 파일도 동일함 

스프링 부트는 내가 개발하려는 프로젝트에 따라서 관련된 라이브러리의 묶음 같이 다운 받아줌 (= 적은 설정으로 내가 원하는 라이브러리를 다운 받을 수 잇음 )

자바소스 설정보다 외부프라퍼티 설정이 우선순위가 높음 (application.properties)





스프링부트의 등장 

웹 어플리케이션만을 위해서 만들어진게 아니라 범용적인 프레임워크임 







-----





12/04

2001년에 아이바티스 2.2 가 마지막 버전 -> 2010년에 마이바티스로 이름 변경 v 2.3 

- 중간에 2005년도에 스프링 나옴 
- 스프링 + 아이바티스 연동하려면 후발주자인 스프링이 API 제공 
- 마이바티스 + 스프링 연동할땐 마이바티스에서 API 제공
- 마이바티스와 아이바티스 문법은 똑같지만 구글제공이냐 아파치 제공이냐 다름 



SQL 세션 객체  == 마이바티스 컨테이너  == SQL Map

- 웹에서 사용하는 세션 개념과 다름
- 마이바티스 세션객체를 생성하려면 메인 환경설정 파일을 읽음 (무슨 디비랑 연결할지(datasource), 어떤 sql 파일들이 등록이 되어있는지 ) 
- 네임스페이스가 중요한 이유는 똑같은 컬럼명에 똑같은 데이터가 있을 수 잇어서 구분용임 . 좀더 유니크한 아이디 제공 
- sql 이 등록되어 있는 수만큼  mapped statemen 객체 생성 
  - 메모리에 떠잇는 mapped statemen 객체 를 아이디로 구분함 ( 아이디의 중요성! )



메이븐

- 프로젝트 만드는데 도움
- 프로젝트를 운영서버에 배포하고 관리하는데 도움 
- 프로젝트 전반에 걸쳐 많은 도움 
- 중요 기능 2가지 :
  - 라이브러리 관리
  - 프로젝트 템플릿 제공 
- 모든 개발자들이 똑같은 프로젝트를 공유 (디렉토리 구조 유추 가능 )
- 만들때 여러가지 템플릿 제공해줌 
  - quickstrat : 일반 자바 프로젝트 
  - webpp : 웹 프로젝트 
- 만들때 패키지 이름에 프로젝트명이 같이 붙어잇는 경우는 없음 



gradle은 언어에 종속되지 않지만 메이븐은 자바에섬나 쓸수잇고 자바에 최적화 

과제

1. 스프링프레젠테이션프로젝트 파일 -> 스프링 웹프로젝트로 옮김 
2. 디펜더시 라이브러리 추가 (https://mvnrepository.com/artifact/com.h2database/h2/1.4.199) < 이 사이트에서 서치해서 넣으면 됨 

-------







12/03





----------





12/02

서블릿컨테이너 + 스프링컨테이너 두 종류가 필요함 

톰캣서버 스타트 -> 웹.xml 파일을 서블릿 컨테이너가 로딩함 -> **브라우저가 요청을 해야** 서블릿컨테이너가 서블릿 객체를 생성 (레이지 로딩임... 필터와 리스터는 프리로딩 ) -> 무조건 이닛 메서드 실행 -> 이닛파람이라는 설정 정보를 로딩 함 -> 디스패처 서블릿이 스프링 컨테이너 생성 

foword 방식은 빠름 (브라우저가 있고 a.jsp, b.jsp 가 있을 때 브라우저가 에이를 호출하면 에이가 비를 실행해서 화면에 출력 )지만 url 이 변경되지 않음 (서버 안에서 변경됨 )

리다이렉트방식은 에이 요청했을때 비를 보여주고 유알엘도 비로 보여줌 

- 얘는 일단 브라우저가 에이를 요청 -> 에이가 비를 호출하라고 브라우저에 응답 -> 브라우저가 다시 비를 요청 -> 응답
- 그래서 속도가 느림 



컴포넌트 스캔 설정

```xml
<context:component-scan />
```





컨터이너는 총 세개가 필요 (스프링컨테이너가 두 개 )

서블릿 컨테이너 는 *서블릿 객체* 와 *리스너 객체*를 생성하고 관리 함 

디스패처 서블릿이 생성하는 컨테이너는 웹어플맄이션콘텍스트 



ioc는 객체에 대한 역제어임 -> 객체에 대한 제어를 컨테이너가 담당 

1. 객체생성 : 컨테이너가 함
2. 객체와 객체관의 의존관계 : 컨테이너가 함 



원래 컨트롤러가 DAO를 직접 이용하면 안됨 DAO 수정이 필요하면 전부 고쳐야하기 때문에 ...







----------------------







11/30

디비연동을 마이바티스나 다른걸로햇다면 *org.springframework.jbdc.datasource.DataSourceTranasctionManager* 무조건 이거 사용 



트랜잭션 Advice 클래스

- 유일하게 트랜잭션 관리 Advice 클래스만 우리가 구현하지 않는다 -> 할 수도 있지만 경우의 수가 많고 복잡하기 때문에 직접 만들지 않음 
- tx 접두사(tx namespace 추가)로 시작하는 태그를 적절히 설정하면 스프링 컨테이너가 자동으로 트랜잭션 관리 Advice 객체를 생성 
- 

 서블릿 컨테이너 => 톰캣 서버

스프링 컨테이너 => 디스패쳐서블릿

이 만들어줌 





--------------









11/27

조인포인트는 모든 비즈니스 메서드임 .. 

클라이언트가 일반 조인포인트에 해당하는 메서드를 호출할 땐 아무런 변화가 없음 

행단관심에 해당하는 공통기능의 메서드 (어드바이스) 가 동작하려면 포인트컷으로 필터링된 메서드에 대해서만 동작함 

어떤 패키지, 어느 클래스의 무슨 메서드를 포인트컷을 이용해 필터링 필요. 메서드의 매개변수... 포인트컷

핵심관심, 비즈니스 로직 필터링 함 

아무리 포인트컷, 어드바이스 메서드를 잘 만들어도 어스펙트 를 구현하지 않으먄 aop 는 동작하지 않음

어스펙트 설정은?

어스펙트는 야 컨테이너야 모든 비즈니스 메서드가 실행되기 직전에 로그 어드바이스 객체가 가지고 있는 프린트로그라는 메서드를 실행해라 -> 포인트컷, 비즈니스 메서드와 어드바이스(횡단관심) 메서드를 적절하게 연결해주는 연결고리가 어스펙트

포인트컷이 반드시 설정되어 있어야 함. 포인트컷 태그를 이용하고 아이디를 바르게 해서 다른 포인트컷과 구분 필요 

allPointcut -> 리턴타입이 뭐가 되엇든지 신경스지 마라. .. 모든 메서드 

getPointcut -> 리턴타입과 매개변수 무시하고 get으로 시작하는것만 필터링 ..  겟으로 시작하는 메서드 

어스펙트 == 어드바이저 

- 포인트컷과 어드바이스의 결합

위처러 xml 설정도 가능하지만 어노테이션 @어쩌구 도 가능 

`<aop:aspectj-autoproxy></aop:aspectj-autoproxy>`  설정으로 사용 가능함  

-> 이거 안 쓰면 aop 관련 메서드 동작하지 않음 



모든 비즈니스 메서드를 필터링 하는 게 의미가 있을까?

- 필터링이란건 전체중에 내가 원하는 일부분을 묶었을때 필터링. ..

- 조인포인트(=일반메서드)는 포인트컷 후보다 
- 올포인트컷을 참조해서 모든 비즈니스 메서드가 실행되기 직전에 이런메서드가 실행되면 돼 @Before 어노테이션 



ㅇ애프터로 동작하는 메서드는 비즈니스 로직의 리턴값을 받아낼 수 없음 

어라운드는 비즈니스로직을 기준으로 사후처리와 사전처리를 모두 할 수 잇음 







스프링 엠브이씨 

jdbc 프로그램의 문제

- 프로그램 순서가 정해져잇음 -> 드라이버로딩, 커넥션연결,스테이트먼츠생성,에스큐엘전송,스테이츠먼츠클로즈 (하나라도 순서 바뀌면 안됨 )
- 같은 코드를 반복함 (디비연결 및 스테이트먼츠 생성 등 )



데이터 소스를 사용하지 않고 디비연동을 하면 시간이 오래걸리는 ㅈ단점이 잇음 (커넥션 맺는 시간이 오래걸림 )







-----------------------





11/25

AOP (Aspect Oriented Programming) 

- 관점지향 프로그래밍 
- OOP 의 단점을 극복할 수 있도록 도와주는, OOP를 OOP 답게 더 강화시켜주는 거지 대체하는 개념이 아님



비즈니스 메서드들은 자기 이름으로 해당하는 로직으로 변경 

비즈니스 로직과 횡단로직에는 아무런 접점이 없음~ 객체지향을 뛰어넘는 것 

aop 는 용어만 잘 정리해도 됨 (다섯가지 존재 )

- 포인트컷 (Pointcut)
- 어드바이스 (Advice)
- 어스펙트 (Aspect) = 포인트컷 + 어드바이스 





### *\*\* ppt 조인포튼ㅌ,포인트컷,어드바이스,위빙 읽고 오기 *\*\*



-------------------------









11/24

### Spring Tool Suite(STS) 설치하기 

- 얘를 설치하지 않으면 실습을 못하는 건 아닌데 노다가성 작업이 많음. 스프링부트에선 반드시 사용
  1. 이클립스에 플러그인 추가
  2. 아예 STS 를 다운 받는 게 있음 



#### 프레임워크란?

- 아키텍처에 해당하는 골격을 제공 
- 



```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" >
  
	<!-- 컨테이너가 이 xml 을 로딩하는 순간 other.xml 도 로딩하겠단 의미  -->
	<import resource ="other.xml"></import>

```

- xmlns : name space(이름 공간) beans 라는 루트 카테고리에서 xmlns 라고 등록된 네임 태그만 써야함 
- http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
  - 어떤 태그를 써야하는지 보고 싶으면 위 링크로 이동 필요 
  - 위 파일 기준 `description`, `alias`, `import`, `beans` 사용 가능하지만 `import`, `beans`  만 사용
    - description : 주석
    - alias : 주석 



```xml
<!-- applicationContext.xml -->
<!-- 스프링 IoC 컨테이너가 생성할 객체를 bean 등록한다 (Pre-Loading) -->
<bean id="tv" class="pholymorphism4.GoogleTv" 
			init-method="멤버변수초기화" 
			destroy-method="자원해제" 
			scope="prototype"></bean> 
```

- 컨테이너는 이 xml 파일을 로딩 -> xml을 통해 스프링 컨테이너를 제어할 수 있다 
- xml에 따라서 컨테이너 동작이 달라짐
  - 뼈에 해당하는 아키텍처와 살에 해당하는 비즈니스 로직을 연결 시켜주는 게 xml 환경설정 파일
- 여기서 `id` 와 `name` 태그는 같은 속성이지만 id 태그 사용 권장
  - id는 숫자로 시작할 수 없고 공백과 특수기호를 포함할 수 없다 (= 자바 변수 이름 규칙과 동일)
  - name 은 자바 변수명 규칙을 따르지 않아서 특수문자가 가능. 굳이 내가 특수한 id 속성을 사용하고 싶을 때 사용
- scope="singleton" : 생략가능.디폴트가 singleton 임. 클라이언트에서 여러번 요청해도 한번만 메모리에 띄움 
- scope="prototype" : 클라이언트가 요청할때마다 매번 새로운 객체를 메모리에 띄워줌 (이렇게 세팅할 일은 거의 없음 ) 







## Dependency Injection 의존성 주입. 

- IoC 중 가장 핵심임 . 객체와 객체간의 관계를 컨테이너가 조정함 
- Constructor Injection : 생성자를 기준으로 함 
- 객체 생성과 의존관계를 컨테이너가 하게 됨 
- 실프로젝트땐 세터인젝션만 사용함 
  - 생성자 인젝션은 변수가 여러개일때 뭐가 초기화될지 모르기때문에 초기화 할때 멤버변수를 고려서  경우의 수만큼 해야되는데 
  - 세터인젝션은 각각 하나식만 만들어주면 됨 









### Annotation





-----------------------



11/23 

mvc -> model1 아키텍쳐 

- 90년대 말부터 지금까지 쓰고 있는 웹 아키텍쳐
- 브라우저가 있고 서버가 있으면 서버 안에 있는 jsp, javabean(= vo, dao. 데이터베이스로 부터 데이터를 가져옴 ) 만을 이용해서 웹을 구현했던 구조가 모델1 아키텍쳐 
- 자바 코드와 html 코드가 섞여 있기 때문에 디자인 변경이 어렵고 유지보수가 힘듦 
  - 자바로직을 jsp에서 분리 -> mvc 아키텍쳐 
- 역할분담을 명확하게 하자는게 목적임 
  - JSPProject 에서  _proc 라고 이름 붙은건 다 삭제하고  .jsp와 .html 만 남아야댐 
- 컨트롤 로직이라고 함은 입력정보추출, DB연동, 화면 이동만 포함
  - 세션에 등록, 이프문 포문 등은 컨트롤이 아님. 아무리 mvc아키텍쳐 모델 써서 자바 코드 들어낸다고 해도 if/for 이런 자바 코드는 남아있을 수밖에 없음 
  - 근데 jsp에서 이런 자바 코드까지 다 없애고 싶다면? -> 



#### JSP EL JSTL 검색 

EL (Expression Language) 이란?

- JSP 파일에서 request나 session( = 내장객체) 에 등록한 데이터를 접근하기 위한 표현식 
- JSP에서 완벽하게 자바 코드 삭제 
- 리퀘스트에서 먼저 찾고 적용함 (우선순위가 리퀘스트가 높음 ) 
- 대소문자 구분함 



JSTL (JSP Standard Tag Library) 이란? 

- JSP 파일에서 if(), for(), switch() 등과 같은 자바 코드를 대체하는 JSP 표준 태그 
- jstl, standard 라이브러리는 이것과 관계 없음 



검색결과를 저장하면 메모리 장비

세션에 저장하는 거 id, 권한 정도 





### 스프링

프레임워크(Framework)가 뭐임? 

- 사전적 의미는 뼈대, 혹은 골격을 의미 
- 아키텍처를 제공함 
- 1 / 2  두 사람이 각각 10년차 개발자와 신입이라고 할때 인형을 만들라 하면
  - 1은 역동적인 인형을 좋아햇어 -> 그걸 만듦
  - 2는 대학에서 배운 표준화된 인형을 만듦  
  - 2가 만든 인형을 쓰다가 고장나서 유지보수를 해야하면 다른 사람이 구조를 ㅏ파악해야됨 (원래 인형이 팔다리가 있으며 ㄴ어떤 모양인지... ) -> 설계도를 보고 원래 모양을 만들어야 하는데 설계도를 보지 않고 만들면 망함 
  - 소프트웨어 개발 및 유지보수도 같은 개념. 유지보수, 개발 인력이 바뀔 때마다 설계도 를 보고 해야됨 -> 근데 사회적으로 잘 안되니까?? 개발자들의 경험과 능력으로 어케저케 함 -> 일케 되면 일관성을 잃어버림 
- 이렇게 되지 않기 위해서 뼈대는 프레임워크가 제공 -> 인형의 살만 개발자가 만들어라!!!! 
- **프레임워크 : 아키텍처에 해당하는 골격/뼈대를 제공**하겠다. (아키텍쳐 == 뼈대/구조/골격, 인형 == 프로그래밍)
- 그래서 시간이 흐르고 개발자가 바뀌어도 구조는 바뀌지 않음 ( = 뼈대는 바뀌지 않음. 살은 바뀔 수 있다... )





이걸 사용하면?? 

- 자바 소스 수정없이 유지보수 가능 -> 컴파일을 다시 안 해도 됨 
- 개발자의 역량 획일화 
  - jpa : sql을 프레임워크가 만들어줌 
- 빠른구현시간
- 관리 용이성 증가 
- 검증된 아키텍처의 재사용과 일관성 유지
  - 아키텍처를 개발자가 작성하지 않음. 수많은 레퍼런스를 가진 검증된 회사에서 만듦 
  - 아키텍처가 재 사용된다는 건 여러 시스템이 있을때 그 시스템이 같은 프레임워크로 되어있다면 아키텍처는 똑같다. 시간이 흐른다고 아키텍처가 변경되거나 깨지지 않음 



java 기반의 Framework

- 대부분 오픈 소스 (라이센스가 있지만 사용할 때 별도의 비용을 지불하지 않음 )
  - 오픈소스는 이걸 제공하는 회사의 선의에 따른ㄴ 거임. .. 무료가 장점이 아님. 
  - 장점은 오픈소스를 상속해서 MySpring 나만의 프레임워크를 쉽게 만들 수 있다는 것임 
- 아이바티스 / 마이바티스
  - 접근하기 쉽고 개발자가 xml 파일에 쿼리를 작성함
  - DBMS 가 바뀌면 죄다 뜯어 고쳐야 함 
  - 우리나라에서 많이  씀 
- JPA/
  - 접근하기 어렵고 배우기 어려움 
  - 쿼리도 개발자가 안 쓰고 DBMS가 바뀌어도 설정에서 수정해주면 됨 
  - 세계적인 트렌드임 
- 스프링 프레임워크는?
  - 가벼움
    1. 라이브러리자체가 사이즈가 작아 가볍다고 함 
    2. **POJO**(Plain Old Java Object) : 평범한 옛날 자바 객체.. <--> Not POJO : POJO가 아닌 클래스는 클래스를 작성하는데 엄격한 규칙을 적용받는다.  반대로 POJO로 구현된 클래스는 아무런 규칙이 없다 . POJO로 구현된 클래스는 메모리 사용량이 매우 적은 특징을 갖는다. 
       - POJO 라고 했을 때 hello world 를 떠올리면 됨 
       - 스프링은 포조를 기반으로 하기 때문에 가벼움 
  - 스프링은 컨테이너다 (Container )
    - web.xml 로딩 -> 브라우저가 그 서블릿을 요청 -> 서블렛 엔진(= 컨테이너) 에 생성된 객체를 관리하는 역할 
      - 인버전 오브 컨트롤 (= 역제어 ) <-> 
    - 서블릿 엔진은 실제로 서블릿 컨테이너 
    - 스프링도 컨테이너를 제공함 
    - 스프링은 컨테이너가 생성될때 xml에 작성된 클래스 객체들이 요청을 하지 않아도 컨테이너가 생성되는 순간 같이 생성되지만 서블릿은 서블릿엔진(서블릿컨테이너)가 생성될때 같이 생성되지 않음 
    - 디폴트 생성자가 없으면 스프링컨테이너는 그 클래스 객체를 생성해주지 못 함 





--------------------------







11/20

- 필터 체인 
  - 기능 하ㅈ  당 필터 

listener 클래스고 뭘 임플리먼츠 할거임 ?->Lifecycle 

context = 엔진(원래는 문맥인듯 ) ;

필터를 이용해서 세션정보 넣기 ... (삭제, 수정, 목록보여주기 등 )



jsp

서블릿의 장점은 자바로 구현되서 플랫폼에 자유롭고 서버에 종속되지 않아서 이식성이 높고

서블릿 클래스만 잘 만들면 서블렛 엔진이 하나의 서블렛 객체를 멀티 스레드로 사용할 수 잇어서 빠르고 효율적이지만

단점이 너무 많암.

- 일단 서블릿은 web.xml 에 등록을 해야 됨 . 서블릿 위저드 이용해서 서블릿 하나 생성할 때마다 web.xml에 추가 필요(이클립스라서 자동으로 해주는 거임 )
- 응답화면을 구성해줘야 함. 이 때 한글이 포함되어 있을 수 있어서 response.setContentType("text/html; charset-EUC-KR") 인코딩 설정 해줘야함 
  - printWriter out = response.getWriter(); 로 html 화면 구성해야됨 (out.println("<\html>" ); 이런식으로  
  - html 화면 구성할때도 자바 문법에 맞는지 안맞는지 체크해야 함 
- 뭔가 수정하고 브라우저 새로고침한다고 반영되는게 아니라 리로딩이 되어야 함 

이런 단점을 개선시키고 나온게 jsp

jsp는 **디자인 중심**이고  내가 쓰고 싶은만큼의 자바 코드만 사용을 함 

<%= 자바코드 %> 이런식으로 사용 (익스프레션, Expression) << 변수, 메소드(리턴 타입이 보이드가 아닌 것만, 리턴하는 메서드만 가능함 ) 호출 가능 

<%                 %> (스크립틀릿 이라고 부름, Scriplet) << 일반 자바 코드 

- webContext 폴더에다 만듦 - new JSP -> next -> 4.1 템플릿  로 생성 
- web.xml 등록 안 하고 파일만 만들면 됨 
- css 요소를 넣고싶으면 <font color="red"\><%= 자바코드 %></font\>  식으로 디자인을 바꾸기 쉬움. 
- 리로딩 타임을 기다릴 필요가 없음 

localghost -> JSPProject -> org -> apache -> jsp ->  hello_jsp.java 가 만들고 .cless 를 컴파일 함  

hello_jsp.jav 를 src 폴더에 넣어줌 - > 디폴트소스에 넣어지는데 오류 확인하기 위해서  



서블릿 배운 이유 

- JSP 정확히 디버깅하려고 

- 스프링 MVC 배울때 반드시 필요 



_jspService 메서드 안으로 내가 작성한 모드 코드가 들어가는데 매개변수 로 request, reponse 가 있기 때문에 

request, reponse  를 선언하지 않고 그냥 쓸 수 있음 

html 주석은 jsp가 서블릿으로 변환될때 포함이 되지만  <%-- --%> 이건 서블릿에 포함되지 않음 

- 그래서 <%--%> 주석을 쓰는 경우는 거의 없음 



getboardlist.jsp

tr 하나만 남기고 삭제 >

```java
<% for (BoardVO board : boardList ) { %>
  <tr>
  		<td><%= board.getSeq() %></td>
  		<td align = 'left'><a href ='getBoard.jsp?seq=2>'<%= board.getTitle() %></a></td>
    	<td><%= board.getWriter() %></td>
    	<td><%= board.getRegDate() %></td>
    	<td><%= board.getCnt() %></td>
  </tr>
 <% } %> 
```



#### 월요일 과제

- 새글 등록, 수정, 삭제, 검색까지 jsp 로 기능 구현하기 
- 한글인코딩 세션정보 처리 





---------







11/19



브라우저가 넘겨준 요청 프로토콜 스타트라인 - 메시지헤더 - 메시지바디 에 있는 정보들을 리퀘스트 객체에 담아서 전달함 

`request.getRequestURI()`

request.get~ 으로 시작하는 ㄴ메서드는 모두 사용할 수 있음 

리퀘스트와 리스펀스 객체는 내가 생성하는게 아니라 서블릿 엔진이 호출하고 알아서 해주는 거임 

내가 하는 건 다섯가지 규칙 기억해서 문법에 맞게 클래스 작성해서 web.xml에 등록해주는 것 

서블릿은 실제 프로젝트에서 사용하지 않음 (눈에 보이지 않게 사용하는 것. ...) -> 스프링 프레임워크로 서버 개발할건데 서블릿의 라이프사이클, API 등을 모르고선 스프링을 쓸 수 없음 





게시판 만들때 필요한 기술

 SQL,   JDBC,  HTML,  Servlet 





링크 물음ㅍ 뒤에 딸려가는 걸 쿼리 스트링이라고 함 





서블릿은 브라우저(= 클라이언트) 가 요청해야 서블릿 객체가 메모리에 올라감

- Lazy-Loading 

Filter 는 클라이언트의 요청이 필요없음. 서블릿엔진이 web.xml을 읽자마자 생성됨

- Pre-Loading





init 메서ㄴ드는 생성, destroy 는 삭제 -> 필터에서는  둘다 꼭 오버라이딩 해둬야 함 아무것도 쓸게 없으면 빈 내용으로 오버라이딩 필요 init, doFilter, destroy... (다른 곳에서 이닛과 디스트로이는 필요하지 않음 )

- ​	두필터는 중요함 





-----------------------





11/18

http

t서블렛은 어렵지 않음 열번 만들어보셈 



`Tomcat server = new Tomcat();` 으로 톰캣 서버 실행 가능 

톰캣가지고 작업하다가 이클립스 상에서 톰캣을 죽엿는데 백그라운드에서 살아있는 경우가 있음

포트 충돌, 서버가 구동이 안된다는 메세지 등 

- 해결방법 : 작업 관리자 -> 서비스 -> 자바로 되어있는 서비스를 강제로 죽임 => 백그라운드에서 도는 톰캣이 죽음 



**중요!!!**

Catalina 서버 == 톰캣 서버 

이클립스 콘솔창에서 

톰캣서버가 구동됐다. 에러가 안 나면  -> 정보 : Starting Server [Catalina]

문제없이 실행됏다 -> 정보: Starting Servlet Engin 

- 브라우저의 기능과 서버의 기능을 어느정도 알고 가야 함 



톰캣 말고도 서버의 종류는 다양함( 제우스, 웹로직  어쩌구.. )

- 다른건 유로라서 톰캣 슴 



초록색 화살표 눌럿 ㅓ톰캣서버 구동

- 톰캣서버는 자바로 만들어졋잇다  

- 내부적으로는 톰캣서버가 객체로 생성되는 것 (new Tomcat(), 톰캣은 클래스에 불과함 )

- 톰캣 객체가  Servlet Engin 을 생성함 ( 생성하는 코드를 가지고 있음 )

  - 이 서블릿 엔진 객체가 생성될 때 web.xml 파일이 전달됨(= 로딩 ) (web.xml 파일의 중요성 )
    - web.xml에 오류가 있으면 서버 구동시 오류 출력 
  - 톰캣 안에 있는 서블릿 엔진이 메서드 호출함 (HelloServlet(), doGet()) 
  - 나는 클래스만 만들고 객체생성 메서드 호출은 서블릿 엔진이 함 < 이거 중요 

- 서블릿은 톰캣 서버 없이 절대 실행할 수 없음 

  

  

서블렛 특징(자료 올림 )

- 자바 클래스다. 서블렛 엔진에 의해서만 객체 생성되고 동작함 
- 요청하는 클라이언트가 몇개던간에 엔진은 서블릿 객체 하나만 메모리에 올림 (우선 요청하는 서블릿객체가 메모리에 있는 체크함 )
  - 엔진은 디폴트 생성자만 봄. 매개변수가 잇는 생성자를 보지 않음 . 
- 자바 클래스이기때문에 플랫폼에 무관하고 웹서버에 무관함  (= 이식성이 좋음 , 소프트웨어 품질에서 중요한 부분 )
- 서블릿 규칙에 맞게 작성하면 톰캣, 제우스 등 다른 서버에서도 똑같이 실행 됨 
- 자바로 작성되었기 때문에 외부 프레임워크 등을 클래스 라이브러리 형태로 사용 가능함 
- **멀티 스레드 **.서블렛은 멀티 스레드로 동작하기때문에 웹 환경에서 효율적임
  - 서블릿을 멀티 스레드로 동작시키는건 서블릿 엔진이 하는 일 임 (개발자가 하는 일 아님 )
  - 서블릿 엔진이 web.xml 로딩하면 스레드 객체들이 저장되어 있는 thread pool 생성 
- 서블릿 라이프 사이클 이해하기 (자료 있음 타이틀 - 서블릿 수행 흐름 )

- 서블릿 클래스의 다섯가지 규칙. 외워야하지만 이클립스가 이 규칙에 맞게 클래스 생성해줌 
  - 1. HttpServlet 클래스를 상속해야 한다. 
    2. public 클래스로 만들어야 한다. 
    3. default 생성자가 있어야 한다. 
    4. 요청 방식(method)에 따라 doGet(), doPost()를 재정의(Overriding) 한다.
    5. 부모(HttpServlet) 클래스의 메소드를 제정의 하지 않으면 상속된다. 

- 서블렛으로 개발한 시스템은 클라이언트 오픈 전에 한번다 실행해야됨 왜냐면 처음 실행하면 메모리에 올리고 스레드 할당하기때문에 두번째 할 때보다 시간이 소요됨. 





HTTP  (강의자료 올림 )

- 프로토콜임 (= 통신규약, 약속. 반드시 지켜져야 함 )
  - A회사 b회사는 각각 쇼핑물을 운영하는데 b는 재고가 없고 a는 재고가 많음 -> 서로 물건을 주고 받기로 약속함 
  - 프로토콜은 한 번 정해졌으면 바뀌면 안됨 이게 바뀐다는 얘기는 엄청나게 많은 프로그램이 바뀌어야 함 
  - webserver(우리는 톰캣 씀 ) 
  - 모든 브라우저는 사용자가 버튼을 누르거나 링크를 ㅌ클리하면 등의 행위를 하면 서버에 http 요청 프로토콜을 보냄 
  - 그럼 서버가 브라우저가 보내준 요청 프로토콜 받아서 해석함 -> 그에 걸맞는걸 실행 -> 다시 브라우저에 응답 프로토콜을 보냄 -> 브라우저는 그걸 분석해서 display ==> 이게  웹 브라우저 / 서버 통신 
  - http request - CRLF == 빈칸 (헤더와 바디를 구분하는 공백 )
  - http response - CRLF == 빈칸
  - **버튼, 링크 누름, 직접 url 입력 -> http 요청 프로토콜 생성**
  - 요청 프로토콜의 시작과 끝이 중요하지 header는 중요하지않음  (헤더 내용은 브라우저마다 다름)
    - start line : 3개의 데이터로 구성. 각각 요청 방식(GET/POST), URI정보(url에서 포트번호를기준으로 그 뒤 문자 ), 요청에 사용된 프로토콜의 이름과 버전(불변임)
    - message body: 사용자가 입력한 정보(값), 요청방식이 POST일 때만 바디에 들어감.... 
  - 응답 프로토콜 
    - start line :  http버전, 응답상태코드로 구성 
      - 404: 서버안에 있는 프로젝트 안에 있는 파일이 없거나 톰캣서버 안에 있는 서블릿엔진(.do 파일 처리)..web.xml 내에 호출하지 않은 파일 
      - 405: 요청방식 메서드가 없을때 (서버가 지원하지 못 한다는 메시지 출력.)(각방식에 따라 메서드를 가지고잇어야함 ,doGet / doPost)
      - 500: 실행 오류  
    - message body: 브라우저가 요청한 문서(엑셀, html 등 )가 응답 프로토콜 바디 쪽에 담겨서 전달 





어떤 파일이 어느 디렉토리에 있는지 외워야함







--------------





11/17

---- 롬복 활용법 알아오기 



클라이언트 : 객체에 한해서 나(메서드)를 사용해주는 또 다른 누군가 



resources - new - other(sql development) - sql file - next - file name: create_users.sql

뉴 - 다이나믹 프로젝트  (혹은 프로젝트 - 다이나믹 프로젝트) - HTTPProject - Targetruntime(=서버) 에서 뉴 런타임 - 아파치 톰캣 

.java => src 아닌건 resources에 저장 



// GetUserTest.java

conn = JDBCUtil.getConnection(); // creat method 

- getConnection : 스태틱 메서드 
- 파일 이동해서 주석 지우고 1. 드라이버 객체 로딩 트라이 캐치문 복붙 
  - 트라이 문 안에 class.forName 아래 return DriverMad어쩌구 저쩌구 
  - add 캐치어쩌구 추가해서 캐치문 추가 
- 파이널리 블럭 잘라내고  `JDBCUril.close(rs, stmt, conn);`
  - 메서드로 만듦
  - SELECT 기능의 자원 해제 
  - 하나 더 복사해서 오버로딩 시킴 -> 셀렉트가 아닌 not Select 기능의 자원해제 
    - 매개변수로 리절트셋 없고 stmt,  conn 만 받음 
- 인서트보드 테스트 열고 드라이버 로딩하고 커넥션까지 삭제하고 JDBCUtil.getConneciont(); 
  - 파이널리에서 `JDBCUril.close(stmt, conn);`

검색결과가 단건일때 -> if / 많을 때 while(true) 루프 필요 

DBMS에 비종속적 -> DB가 달라지면 쿼리문, connection 객체만 변경, 자바 소스는 변경필요 없음 

**PreparedStatement** : sql 처리 속도가 일반 Statement보다 5배 빠름  -> 사용방법이 달라짐 대신... 

- 결과는 같음 성능만 달라짐 

상속(Extends)은 부모가 가진 변수나 메서드를 물려받는데서 끝나는 게 아니라 부모가 가진 거 외에 더 많은 변수와 메서드를 확장해서 기능 추가 가능 

1. sql문을 받으면 디비에서 제일 먼저 확인하는 건 문법 체크 (= 파싱 , sql 파싱)

2. 오브젝트 확인 (테이블 유무 확인)

이걸 모두 확인해야 데이터베이스 메모리에 올라감 

매번 sql 문법 체크 오브젝트확인 하기 싫으니까 **PreparedStatement** 사용 

- 이걸 하면 ? 로 들어감 . 메모리에 올라갓는데 sql을 바로 실행 
- 
- 



src 보드 패키지 선택 - 오른쪽 마우스 - 새로운 클래스 생성 BoardDAO 

```java
// DAO (Data Access Object) 클래스 
public class BoardDAO {
  // JDBC 관련 변수 선언
  private Connection conn;
  private PreparedStatement stmt;
  private REsultSet rs;
  
  // BOARD 테이블 관련 SQL 명령어
  private static final String BOARD_INSERT = "INSERT INTO BOARD(SEQ, TITLE, WRITER, CONTENT)"
    																					+ "VALUES((SELECT NVL(MAX(SEQ)) + ! FORM BOARD), ?, ?, ?)";
  private static final String BOARD_UPDATE = "UPDATE BOARD SET TITLE =?, CONTENT = ? WHERE SEQ = ?";
  private static final String BOARD_DELETE = "DELETE BOARD WHERE SEQ = ?";
  private static final String BOARD_GET = "SELECT * FROM BOARD WHERE SEQ = ?";
  private static final String BOARD_LIST = "SELECT * FROM BOARD ORDER BY SEQ DESC";
}

// BOARD 테이블 관련 CRUD 기능의 메서드
// 글 등록
public void insertBoard(String title, String writer, String content) {
  try {
  	conn = JDBCUtil.getConnection(); // 커넥션 얻음 
    stmt = conn.prepareStatement(BOARD_INSERT);
    stmt.setString(1, title); // sql이 ? 라서 각 123번 ?를 적절하게 세팅 
    stmt.setString(2, writer);
    stmt.setString(3, content);
    
    stmt.executeUpdate(); // 데이터베이스에 전송 
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    JDBCUtil.close(stmt, conn);
  }
}

// 글 수정
public void updateBoard(String title, String content, int seq) {
  try {
  	conn = JDBCUtil.getConnection();
    stmt = conn.prepareStatement(BOARD_UPDATE);
    stmt.setString(1, title);
    stmt.setString(2, content);
    stmt.setInt(3, seq);
    stmt.executeUdate();
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    JDBCUtil.close(stmt, conn);
  }
}

// 글 삭제
public void deleteBoard(int seq) {
  try {
  	conn = JDBCUtil.getConnection();
    stmt = conn.prepareStatement(BOARD_DELETE);
    stmt.setInt(1, seq);
    stmt.executeUdate();
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    JDBCUtil.close(stmt, conn);
  }
}

// 글 상세 조회 
public void getBoard(int seq) {
  try {
  	conn = JDBCUtil.getConnection();
    stmt = conn.prepareStatement(BOARD_GET);
    stmt.setInt(1, seq);
    rs = stmt.executeQuery();
    
    if (rs.next()) {
      System.out.println(rs.getInt("SEQ") + " 번 게시글 내용 : ") +
        rs.getString("CONTENT"));
    }
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    JDBCUtil.close(rs, stmt, conn); // select 니까 rs부터 역순으로 닫아줘야 함 
  }
}

// 글 목록 검색 
public void getBoardList() {
  try {
  	conn = JDBCUtil.getConnection();
    stmt = conn.prepareStatement(BOARD_LIST);
    rs = stmt.executeQuery();
    
    while(rs.next()) {
      System.out.println(rs.getInt("SEQ") + " : "  + rs.getString("CONTENT"));
    }
  } catch (Exception e) {
    e.printStackTrace();
  } finally {
    JDBCUtil.close(rs, stmt, conn);
  }
}
```







- 인설트보드 테스트 열어서 메인메서드 안쪽의 모든 코드를 컨트롤 쉬프트 슬래쉬 -> 주석처리함 (임포트 는 컨트롤 쉬프트 O )

  ```java
  public static void main (String [] args) {
  	// 1. 글 등록 기능 처리 
  	// 컨트롤 + 스페이스 하면 변수 이름 지정 가능 
    BoardDAO boardDAO = new BoardDAO();
    boardDAO.insertBoard("DAO제목", "DAO", "DAO 내용.....");
  
    // 2. 글 목록 검색 기능 처리 
    boardDAO.getBoardList();
  }
  // 실행하면 6 5 4 3 2 1 하고 글 목록 뿌려줘야함
  // 실행할때마다 seq + 1 
  // 정령방식을 바꾸고 싶으면 DAO 파일에서 order by seq asc 추가 
  
  // 이렇게 하면 코드가 간결해짐 
  ```

  

--------





11/16

- h2databse 는 자바로 만들어진 DB 라서 다운 받고 압축만 풀면 끝남~ 

  - mysql, orcla은 리소스 많이 잡아 먹음 
  - bin > h2w 로 실행 

- h2 -> bin

  - ./h2.sh => java h2 실행 
  - jdbc:h2::tcp://localhost/~/test -> 원격 접속 

  ```mysql
  create table board (
    seq number(5) primary key,
    title varchar2(200),
    writer varchar2(200),
    content varchar2(200),
    regdate date default sysdate,
    cnt int(5) default 0
  );
  
  
  insert into board(seq, title, writer, content) values
  (1, '가입인사', '테스터', '잘부탁드려요.');
  ```

- RDB -> 관계형 데이터 베이스
- update보더테스는 ResultSet 없이 닫음 (등록수정삭제는 ResultSet 없이 닫음 -> ResultSet사용하지 않기 때문  )
- 내일중으로 이클립스 깔고 오늘했던 프로젝트 소스 실행 



insert 어쩌구에서 

```java
String sql = "insert into board (seq, tilte, writer, content) " 
	+ " values ((select nvl(max(seq), 0) + 1 from board))";
```

- seq가 데이터가 없으면 null 
- nvl(max(seq), 0) + 1 => seq 가 null 이면 0 으로 치환 -> + 1 -> 1 
- 결국 seq는 값을 지정하지 않아도 하나씩 증가하게 됨 





------





# OAuth

[OAuth 란 무엇일까](https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)



## Session Tracking

- 모든 정보를 쿠키(Cookies)에 담아 넘기는 건 초창기 방식



URL(주소)보다 URI 는 광활한 의미?

CR/LF : 엔터쳐서 줄 바꾼 거 

REST PULL

cache-Control: no-cache  -> cache에 있는걸 사용하지 않겠다

curl 

MIME [MIME-Tpye, Content-Type](https://juyoung-1008.tistory.com/4)

[HTTP 상태 코드](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)



 8기가 -> Xmx2048m

16기가-> Xmx4096m 



트랜잭션 

- 계좌이체 예시 
- commit 다 처리 되어야 함  /  rollback 원상태로 돌아감



메이븐ppt 공부하기 ~ 

프로그램기법으로 의존성을 추가할 수 있는 그래들 이 유행 



정적인 웹 파일 : static web file 

web. xml : 

- URL 패턴, dkdk서블렛 이름 등의 설정 



---------------------

